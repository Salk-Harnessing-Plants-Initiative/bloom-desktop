/**
 * Electron Main Process
 *
 * Entry point for the Electron main process. Handles:
 * - Window creation and management
 * - Python subprocess initialization
 * - IPC handlers for Python communication
 */

import { app, BrowserWindow, ipcMain } from 'electron';
import { PythonProcess } from './python-process';
import { CameraProcess } from './camera-process';
import type { CameraSettings } from './camera-process';
import { DEFAULT_CAMERA_SETTINGS } from '../types/camera';
import { DAQProcess } from './daq-process';
import type { DAQSettings } from '../types/daq';
import { ScannerProcess } from './scanner-process';
import type { ScannerSettings } from '../types/scanner';
import {
  getPythonExecutablePath,
  validatePythonExecutable,
} from './python-paths';
import { initializeDatabase, closeDatabase } from './database';
import { registerDatabaseHandlers } from './database-handlers';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// eslint-disable-next-line @typescript-eslint/no-require-imports
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Enable remote debugging for E2E tests specifically
// This must be set before app.ready event fires
// Playwright requires remote debugging to control the app
// Uses E2E_TEST flag (from .env.e2e) instead of broad CI flag to avoid enabling for all CI builds
if (process.env.E2E_TEST === 'true') {
  // Use app.commandLine.appendSwitch() instead of --remote-debugging-port CLI flag
  // because Electron doesn't accept that flag as a command-line argument since v1.6.11+
  app.commandLine.appendSwitch('remote-debugging-port', '0'); // 0 = any free port
  console.log('[E2E] Remote debugging enabled for E2E test environment');
}

// Configuration constants
const STOP_STREAM_TIMEOUT_MS = 2000; // Timeout for stopping camera stream during quit

let mainWindow: BrowserWindow | null = null;
let pythonProcess: PythonProcess | null = null;
let cameraProcess: CameraProcess | null = null;
let daqProcess: DAQProcess | null = null;
let scannerProcess: ScannerProcess | null = null;

// Track current camera settings (in-memory, lost on app restart)
let currentCameraSettings: CameraSettings | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  mainWindow.menuBarVisible = false;
  mainWindow.setMenu(null);

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
};

/**
 * Initialize Python subprocess and set up event handlers
 */
async function initializePythonProcess(): Promise<void> {
  try {
    // Validate Python executable exists
    validatePythonExecutable();

    // Get Python executable path
    const pythonPath = getPythonExecutablePath();

    // Create Python process instance
    pythonProcess = new PythonProcess(pythonPath, ['--ipc']);

    // Forward Python status events to renderer
    pythonProcess.on('status', (status: string) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('python:status', status);
      }
    });

    // Forward Python errors to renderer
    pythonProcess.on('error', (error: string) => {
      console.error('Python error:', error);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('python:error', error);
      }
    });

    // Handle Python process exit
    pythonProcess.on('exit', (code: number | null) => {
      console.log(`Python process exited with code ${code}`);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('python:status', `Process exited: ${code}`);
      }
    });

    // Start the Python process
    await pythonProcess.start();
    console.log('Python process started successfully');
  } catch (error) {
    console.error('Failed to initialize Python process:', error);
    // Send error to renderer if window exists
    if (mainWindow) {
      mainWindow.webContents.send(
        'python:error',
        `Failed to start Python: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
}

// =============================================================================
// IPC Handlers for Python Communication
// =============================================================================

/**
 * Handle python:send-command - Send arbitrary command to Python
 */
ipcMain.handle('python:send-command', async (_event, command: object) => {
  try {
    if (!pythonProcess || !pythonProcess.isRunning()) {
      throw new Error('Python process not running');
    }
    const response = await pythonProcess.sendCommand(command);
    return { success: true, data: response };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('python:send-command error:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Handle python:get-version - Get Python backend version
 */
ipcMain.handle('python:get-version', async () => {
  try {
    if (!pythonProcess || !pythonProcess.isRunning()) {
      throw new Error('Python process not running');
    }
    const response = await pythonProcess.sendCommand({
      command: 'get_version',
    });
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('python:get-version error:', error);
    throw error;
  }
});

/**
 * Handle python:check-hardware - Check hardware availability
 */
ipcMain.handle('python:check-hardware', async () => {
  try {
    if (!pythonProcess || !pythonProcess.isRunning()) {
      throw new Error('Python process not running');
    }
    const response = await pythonProcess.sendCommand({
      command: 'check_hardware',
    });
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('python:check-hardware error:', error);
    throw error;
  }
});

/**
 * Handle python:restart - Restart Python subprocess
 */
ipcMain.handle('python:restart', async () => {
  try {
    if (pythonProcess) {
      await pythonProcess.restart();
      return { success: true };
    } else {
      // If no process exists, try to initialize
      await initializePythonProcess();
      return { success: true };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('python:restart error:', error);
    return { success: false, error: error.message };
  }
});

// =============================================================================
// IPC Handlers for Camera Communication
// =============================================================================

/**
 * Initialize camera subprocess if not already initialized
 */
async function ensureCameraProcess(): Promise<CameraProcess> {
  if (!cameraProcess) {
    const pythonPath = getPythonExecutablePath();
    cameraProcess = new CameraProcess(pythonPath, ['--ipc']);

    // Forward camera events to renderer
    cameraProcess.on('camera-trigger', () => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('camera:trigger');
      }
    });

    cameraProcess.on('image-captured', (dataUri: string) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('camera:image-captured', {
          dataUri,
          timestamp: Date.now(),
        });
      }
    });

    cameraProcess.on('frame', (dataUri: string) => {
      // Check if window still exists and hasn't been destroyed
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('camera:frame', {
          dataUri,
          timestamp: Date.now(),
        });
      }
    });

    cameraProcess.on('status', (status: string) => {
      console.log('Camera status:', status);
    });

    cameraProcess.on('error', (error: string) => {
      console.error('Camera error:', error);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('camera:error', error);
      }
    });

    cameraProcess.on('exit', (code: number | null) => {
      console.log(`Camera process exited with code ${code}`);
      cameraProcess = null;
    });

    await cameraProcess.start();
  }

  return cameraProcess;
}

/**
 * Handle camera:connect - Connect to camera
 */
ipcMain.handle('camera:connect', async (_event, settings: CameraSettings) => {
  try {
    const camera = await ensureCameraProcess();
    const success = await camera.connect(settings);
    return { success };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:connect error:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Handle camera:disconnect - Disconnect from camera
 */
ipcMain.handle('camera:disconnect', async () => {
  try {
    if (!cameraProcess) {
      return { success: true }; // Already disconnected
    }
    const success = await cameraProcess.disconnect();
    return { success };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:disconnect error:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Handle camera:configure - Configure camera settings
 */
ipcMain.handle(
  'camera:configure',
  async (_event, settings: Partial<CameraSettings>) => {
    try {
      console.log('[camera:configure] Configuring with settings:', settings);
      const camera = await ensureCameraProcess();
      const success = await camera.configure(settings);

      // Store settings in memory if successfully configured
      if (success) {
        currentCameraSettings = {
          ...(currentCameraSettings || DEFAULT_CAMERA_SETTINGS),
          ...settings,
        } as CameraSettings;
        console.log(
          '[camera:configure] Stored settings:',
          currentCameraSettings
        );
      } else {
        console.log('[camera:configure] Failed to configure, not storing');
      }

      return { success };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('camera:configure error:', error);
      return { success: false, error: error.message };
    }
  }
);

/**
 * Handle camera:capture - Capture a single frame
 */
ipcMain.handle(
  'camera:capture',
  async (_event, settings?: Partial<CameraSettings>) => {
    try {
      const camera = await ensureCameraProcess();
      const response = await camera.capture(settings);

      if (response.success && response.image) {
        return {
          dataUri: response.image,
          timestamp: Date.now(),
          width: response.width || 0,
          height: response.height || 0,
        };
      } else {
        throw new Error(response.error || 'Capture failed');
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('camera:capture error:', error);
      throw error;
    }
  }
);

/**
 * Handle camera:get-status - Get camera status
 */
ipcMain.handle('camera:get-status', async () => {
  try {
    if (!cameraProcess) {
      return { connected: false, mock: true, available: false };
    }
    const status = await cameraProcess.getStatus();
    return status;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:get-status error:', error);
    return { connected: false, mock: true, available: false };
  }
});

/**
 * Handle camera:get-settings - Get current camera settings
 */
ipcMain.handle('camera:get-settings', async () => {
  console.log(
    '[camera:get-settings] Returning settings:',
    currentCameraSettings
  );
  return currentCameraSettings;
});

/**
 * Handle camera:start-stream - Start streaming frames from camera
 */
ipcMain.handle(
  'camera:start-stream',
  async (_event, settings?: Partial<CameraSettings>) => {
    try {
      const camera = await ensureCameraProcess();
      const success = await camera.startStream(settings);
      return { success };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('camera:start-stream error:', error);
      return { success: false, error: error.message };
    }
  }
);

/**
 * Handle camera:stop-stream - Stop streaming frames from camera
 */
ipcMain.handle('camera:stop-stream', async () => {
  try {
    if (!cameraProcess) {
      return { success: true }; // Already stopped
    }
    const success = await cameraProcess.stopStream();
    return { success };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:stop-stream error:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Handle camera:detect-cameras - Detect available cameras on network
 */
ipcMain.handle('camera:detect-cameras', async () => {
  try {
    const camera = await ensureCameraProcess();
    const cameras = await camera.detectCameras();
    return { success: true, cameras };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:detect-cameras error:', error);
    return { success: false, error: error.message, cameras: [] };
  }
});

// =============================================================================
// IPC Handlers for DAQ Communication
// =============================================================================

/**
 * Initialize DAQ subprocess if not already initialized
 */
async function ensureDAQProcess(): Promise<DAQProcess> {
  if (!daqProcess) {
    const pythonPath = getPythonExecutablePath();
    daqProcess = new DAQProcess(pythonPath, ['--ipc']);

    // Forward DAQ events to renderer
    daqProcess.on('daq-initialized', () => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('daq:initialized');
      }
    });

    daqProcess.on('daq-position-changed', (position: number) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('daq:position-changed', { position });
      }
    });

    daqProcess.on('daq-home', () => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('daq:home');
      }
    });

    daqProcess.on('status', (status: string) => {
      console.log('DAQ status:', status);
    });

    daqProcess.on('error', (error: string) => {
      console.error('DAQ error:', error);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('daq:error', error);
      }
    });

    daqProcess.on('exit', (code: number | null) => {
      console.log(`DAQ process exited with code ${code}`);
      daqProcess = null;
    });

    await daqProcess.start();
  }

  return daqProcess;
}

/**
 * Handle daq:initialize - Initialize DAQ with settings
 */
ipcMain.handle('daq:initialize', async (_event, settings: DAQSettings) => {
  try {
    const daq = await ensureDAQProcess();
    const response = await daq.initialize(settings);
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:initialize error:', error);
    return { success: false, initialized: false, error: error.message };
  }
});

/**
 * Handle daq:cleanup - Clean up DAQ resources
 */
ipcMain.handle('daq:cleanup', async () => {
  try {
    if (!daqProcess) {
      return { success: true, initialized: false }; // Already cleaned up
    }
    const response = await daqProcess.cleanup();
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:cleanup error:', error);
    return { success: false, initialized: false, error: error.message };
  }
});

/**
 * Handle daq:rotate - Rotate turntable by degrees
 */
ipcMain.handle('daq:rotate', async (_event, degrees: number) => {
  try {
    if (!daqProcess) {
      throw new Error('DAQ not initialized. Call initialize() first.');
    }
    const response = await daqProcess.rotate(degrees);
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:rotate error:', error);
    return { success: false, position: 0, error: error.message };
  }
});

/**
 * Handle daq:step - Execute specific number of steps
 */
ipcMain.handle(
  'daq:step',
  async (_event, numSteps: number, direction: 1 | -1 = 1) => {
    try {
      if (!daqProcess) {
        throw new Error('DAQ not initialized. Call initialize() first.');
      }
      const response = await daqProcess.step(numSteps, direction);
      return response;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('daq:step error:', error);
      return { success: false, position: 0, error: error.message };
    }
  }
);

/**
 * Handle daq:home - Return turntable to home position
 */
ipcMain.handle('daq:home', async () => {
  try {
    if (!daqProcess) {
      throw new Error('DAQ not initialized. Call initialize() first.');
    }
    const response = await daqProcess.home();
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:home error:', error);
    return { success: false, position: 0, error: error.message };
  }
});

/**
 * Handle daq:get-status - Get DAQ status
 */
ipcMain.handle('daq:get-status', async () => {
  try {
    if (!daqProcess) {
      return {
        success: true,
        initialized: false,
        position: 0,
        mock: true,
        available: false,
      };
    }
    const status = await daqProcess.getStatus();
    return status;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:get-status error:', error);
    return {
      success: false,
      initialized: false,
      position: 0,
      mock: true,
      available: false,
      error: error.message,
    };
  }
});

// =============================================================================
// IPC Handlers for Scanner Communication
// =============================================================================

/**
 * Initialize Scanner subprocess if not already initialized
 */
async function ensureScannerProcess(): Promise<ScannerProcess> {
  if (!scannerProcess) {
    // Scanner uses the same Python process as other hardware
    if (!pythonProcess) {
      throw new Error('Python process not initialized');
    }

    scannerProcess = new ScannerProcess(pythonProcess);

    // Forward scanner events to renderer
    scannerProcess.on('initialized', () => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('scanner:initialized');
      }
    });

    scannerProcess.on('progress', (progress) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('scanner:progress', progress);
      }
    });

    scannerProcess.on('complete', (result) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('scanner:complete', result);
      }
    });

    scannerProcess.on('error', (error: string) => {
      console.error('Scanner error:', error);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('scanner:error', error);
      }
    });
  }

  return scannerProcess;
}

/**
 * Handle scanner:initialize - Initialize scanner with camera and DAQ settings
 */
ipcMain.handle(
  'scanner:initialize',
  async (_event, settings: ScannerSettings) => {
    try {
      const scanner = await ensureScannerProcess();
      const response = await scanner.initialize(settings);
      return response;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('scanner:initialize error:', error);
      return { success: false, initialized: false, error: error.message };
    }
  }
);

/**
 * Handle scanner:cleanup - Clean up scanner resources
 */
ipcMain.handle('scanner:cleanup', async () => {
  try {
    if (!scannerProcess) {
      return { success: true, initialized: false }; // Already cleaned up
    }
    const response = await scannerProcess.cleanup();
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('scanner:cleanup error:', error);
    return { success: false, initialized: false, error: error.message };
  }
});

/**
 * Handle scanner:scan - Perform a complete scan
 */
ipcMain.handle('scanner:scan', async () => {
  try {
    if (!scannerProcess) {
      throw new Error('Scanner not initialized. Call initialize() first.');
    }
    const response = await scannerProcess.scan();
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('scanner:scan error:', error);
    return {
      success: false,
      frames_captured: 0,
      output_path: '',
      error: error.message,
    };
  }
});

/**
 * Handle scanner:get-status - Get scanner status
 */
ipcMain.handle('scanner:get-status', async () => {
  try {
    if (!scannerProcess) {
      return {
        success: true,
        initialized: false,
        camera_status: 'unknown',
        daq_status: 'unknown',
        position: 0,
        mock: true,
      };
    }
    const status = await scannerProcess.getStatus();
    return status;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('scanner:get-status error:', error);
    return {
      success: false,
      initialized: false,
      camera_status: 'unknown',
      daq_status: 'unknown',
      position: 0,
      mock: true,
      error: error.message,
    };
  }
});

// =============================================================================
// App Lifecycle
// =============================================================================

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  createWindow();

  // Initialize database AFTER window is created so we can send errors to renderer
  try {
    console.log('[Main] Initializing database...');
    initializeDatabase();
    console.log('[Main] Database initialized, registering handlers...');
    registerDatabaseHandlers();
    console.log('[Main] Database initialized and handlers registered');

    // Send success message to renderer
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('database:ready', { success: true });
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error(
      '[Main] Failed to initialize database:',
      errorMessage,
      errorStack
    );

    // Send error to renderer so user can see it in DevTools
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('database:error', {
        error: errorMessage,
        stack: errorStack,
      });
    }
  }

  await initializePythonProcess();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Clean up processes before app quits
let isQuitting = false;
app.on('before-quit', async (event) => {
  // Prevent infinite loop - only run cleanup once
  if (isQuitting) {
    return;
  }

  console.log('App is quitting, cleaning up processes...');
  isQuitting = true;

  // Prevent immediate quit to allow cleanup
  event.preventDefault();

  try {
    // Stop camera streaming first with timeout
    if (cameraProcess) {
      console.log('Stopping camera streaming...');
      let stopStreamCompleted = false;
      const stopStreamPromise = cameraProcess.stopStream().then(() => {
        stopStreamCompleted = true;
      });
      await Promise.race([
        stopStreamPromise,
        new Promise((resolve) => setTimeout(resolve, STOP_STREAM_TIMEOUT_MS)),
      ]);
      if (stopStreamCompleted) {
        console.log('Camera stream stopped successfully');
      } else {
        console.warn(
          'Camera stream stop timed out, force-stopping camera process...'
        );
        try {
          cameraProcess.stop();
        } catch (stopErr) {
          console.error('Error force-stopping camera process:', stopErr);
        }
      }
    }

    // Stop all processes
    if (pythonProcess) {
      console.log('Stopping Python process...');
      pythonProcess.stop();
      console.log('Python process stopped');
    }
    if (cameraProcess) {
      console.log('Stopping camera process...');
      cameraProcess.stop();
      console.log('Camera process stopped');
    }
    if (daqProcess) {
      console.log('Stopping DAQ process...');
      daqProcess.stop();
      console.log('DAQ process stopped');
    }

    // Close database connection
    console.log('Closing database connection...');
    await closeDatabase();
    console.log('Database connection closed');

    // Give processes a moment to clean up
    console.log('Waiting 500ms for processes to clean up...');
    await new Promise((resolve) => setTimeout(resolve, 500));
    console.log('Cleanup wait complete');
  } catch (err) {
    console.error('Error during cleanup:', err);
  }

  // Now allow the quit - use exit instead of quit to avoid triggering before-quit again
  console.log('Calling app.exit(0)...');
  app.exit(0);
});

// Clean up processes when app quits (fallback)
app.on('quit', () => {
  if (pythonProcess) {
    pythonProcess.stop();
  }
  if (cameraProcess) {
    cameraProcess.stop();
  }
  if (daqProcess) {
    daqProcess.stop();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

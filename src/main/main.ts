/**
 * Electron Main Process
 *
 * Entry point for the Electron main process. Handles:
 * - Window creation and management
 * - Python subprocess initialization
 * - IPC handlers for Python communication
 */

import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { PythonProcess } from './python-process';
import { CameraProcess } from './camera-process';
import type { CameraSettings } from './camera-process';
import { DEFAULT_CAMERA_SETTINGS } from '../types/camera';
import { DAQProcess } from './daq-process';
import type { DAQSettings } from '../types/daq';
import { ScannerProcess } from './scanner-process';
import type { ScannerSettings } from '../types/scanner';
import {
  getPythonExecutablePath,
  validatePythonExecutable,
} from './python-paths';
import { initializeDatabase, closeDatabase } from './database';
import { registerDatabaseHandlers } from './database-handlers';
import {
  loadConfig,
  saveConfig,
  loadCredentials,
  saveCredentials,
  loadEnvConfig,
  saveEnvConfig,
  validateConfig,
  fetchScannersFromBloom,
  MachineConfig,
  MachineCredentials,
} from './config-store';

// Config file paths
const BLOOM_DIR = path.join(os.homedir(), '.bloom');
const CONFIG_PATH = path.join(BLOOM_DIR, 'config.json'); // Legacy - will be removed
const ENV_PATH = path.join(BLOOM_DIR, '.env');

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// eslint-disable-next-line @typescript-eslint/no-require-imports
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Enable remote debugging for E2E tests specifically
// This must be set before app.ready event fires
// Playwright requires remote debugging to control the app
// Uses E2E_TEST flag (from .env.e2e) instead of broad CI flag to avoid enabling for all CI builds
//
// NOTE (Nov 2025): The primary fix for the --remote-debugging-port=0 "bad option" error is in
// playwright.config.ts (deletes ELECTRON_RUN_AS_NODE env var). This app.commandLine.appendSwitch
// is kept as defense-in-depth but may no longer be strictly required.
// See: docs/E2E_TESTING.md (Pitfall 6) for full explanation of the root cause.
if (process.env.E2E_TEST === 'true') {
  // Use app.commandLine.appendSwitch() to set debugging flags via Electron's internal API
  app.commandLine.appendSwitch('remote-debugging-port', '0'); // 0 = any free port
  console.log('[E2E] Remote debugging enabled for E2E test environment');
}

// Configuration constants
const STOP_STREAM_TIMEOUT_MS = 2000; // Timeout for stopping camera stream during quit

let mainWindow: BrowserWindow | null = null;
let pythonProcess: PythonProcess | null = null;
let cameraProcess: CameraProcess | null = null;
let daqProcess: DAQProcess | null = null;
let scannerProcess: ScannerProcess | null = null;

// Track current camera settings (in-memory, lost on app restart)
let currentCameraSettings: CameraSettings | null = null;

/**
 * Scanner identity (runtime state)
 *
 * Holds the current scanner name, initialized from .env at startup
 * and synced when config is saved. Provides fast in-memory access
 * for UI components without file I/O.
 *
 * Pattern matches currentCameraSettings (ephemeral runtime state).
 * Pilot reference: bloom-desktop-pilot/app/src/main/main.ts:148
 */
let scannerIdentity: { name: string } = { name: '' };

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  mainWindow.menuBarVisible = false;
  mainWindow.setMenu(null);

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
};

/**
 * Initialize Python subprocess and set up event handlers
 */
async function initializePythonProcess(): Promise<void> {
  try {
    // Validate Python executable exists
    validatePythonExecutable();

    // Get Python executable path
    const pythonPath = getPythonExecutablePath();

    // Create Python process instance
    pythonProcess = new PythonProcess(pythonPath, ['--ipc']);

    // Forward Python status events to renderer
    pythonProcess.on('status', (status: string) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('python:status', status);
      }
    });

    // Forward Python errors to renderer
    pythonProcess.on('error', (error: string) => {
      console.error('Python error:', error);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('python:error', error);
      }
    });

    // Handle Python process exit
    pythonProcess.on('exit', (code: number | null) => {
      console.log(`Python process exited with code ${code}`);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('python:status', `Process exited: ${code}`);
      }
    });

    // Start the Python process
    await pythonProcess.start();
    console.log('Python process started successfully');
  } catch (error) {
    console.error('Failed to initialize Python process:', error);
    // Send error to renderer if window exists
    if (mainWindow) {
      mainWindow.webContents.send(
        'python:error',
        `Failed to start Python: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
}

// =============================================================================
// IPC Handlers for Python Communication
// =============================================================================

/**
 * Handle python:send-command - Send arbitrary command to Python
 */
ipcMain.handle('python:send-command', async (_event, command: object) => {
  try {
    if (!pythonProcess || !pythonProcess.isRunning()) {
      throw new Error('Python process not running');
    }
    const response = await pythonProcess.sendCommand(command);
    return { success: true, data: response };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('python:send-command error:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Handle python:get-version - Get Python backend version
 */
ipcMain.handle('python:get-version', async () => {
  try {
    if (!pythonProcess || !pythonProcess.isRunning()) {
      throw new Error('Python process not running');
    }
    const response = await pythonProcess.sendCommand({
      command: 'get_version',
    });
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('python:get-version error:', error);
    throw error;
  }
});

/**
 * Handle python:check-hardware - Check hardware availability
 */
ipcMain.handle('python:check-hardware', async () => {
  try {
    if (!pythonProcess || !pythonProcess.isRunning()) {
      throw new Error('Python process not running');
    }
    const response = await pythonProcess.sendCommand({
      command: 'check_hardware',
    });
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('python:check-hardware error:', error);
    throw error;
  }
});

/**
 * Handle python:restart - Restart Python subprocess
 */
ipcMain.handle('python:restart', async () => {
  try {
    if (pythonProcess) {
      await pythonProcess.restart();
      return { success: true };
    } else {
      // If no process exists, try to initialize
      await initializePythonProcess();
      return { success: true };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('python:restart error:', error);
    return { success: false, error: error.message };
  }
});

// =============================================================================
// IPC Handlers for Camera Communication
// =============================================================================

/**
 * Initialize camera subprocess if not already initialized
 */
async function ensureCameraProcess(): Promise<CameraProcess> {
  if (!cameraProcess) {
    const pythonPath = getPythonExecutablePath();
    cameraProcess = new CameraProcess(pythonPath, ['--ipc']);

    // Forward camera events to renderer
    cameraProcess.on('camera-trigger', () => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('camera:trigger');
      }
    });

    cameraProcess.on('image-captured', (dataUri: string) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('camera:image-captured', {
          dataUri,
          timestamp: Date.now(),
        });
      }
    });

    cameraProcess.on('frame', (dataUri: string) => {
      // Check if window still exists and hasn't been destroyed
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('camera:frame', {
          dataUri,
          timestamp: Date.now(),
        });
      }
    });

    cameraProcess.on('status', (status: string) => {
      console.log('Camera status:', status);
    });

    cameraProcess.on('error', (error: string) => {
      console.error('Camera error:', error);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('camera:error', error);
      }
    });

    cameraProcess.on('exit', (code: number | null) => {
      console.log(`Camera process exited with code ${code}`);
      cameraProcess = null;
    });

    await cameraProcess.start();
  }

  return cameraProcess;
}

/**
 * Handle camera:connect - Connect to camera
 */
ipcMain.handle('camera:connect', async (_event, settings: CameraSettings) => {
  try {
    const camera = await ensureCameraProcess();
    const success = await camera.connect(settings);
    return { success };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:connect error:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Handle camera:disconnect - Disconnect from camera
 */
ipcMain.handle('camera:disconnect', async () => {
  try {
    if (!cameraProcess) {
      return { success: true }; // Already disconnected
    }
    const success = await cameraProcess.disconnect();
    return { success };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:disconnect error:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Handle camera:configure - Configure camera settings
 */
ipcMain.handle(
  'camera:configure',
  async (_event, settings: Partial<CameraSettings>) => {
    try {
      console.log('[camera:configure] Configuring with settings:', settings);
      const camera = await ensureCameraProcess();
      const success = await camera.configure(settings);

      // Store settings in memory if successfully configured
      if (success) {
        currentCameraSettings = {
          ...(currentCameraSettings || DEFAULT_CAMERA_SETTINGS),
          ...settings,
        } as CameraSettings;
        console.log(
          '[camera:configure] Stored settings:',
          currentCameraSettings
        );
      } else {
        console.log('[camera:configure] Failed to configure, not storing');
      }

      return { success };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('camera:configure error:', error);
      return { success: false, error: error.message };
    }
  }
);

/**
 * Handle camera:capture - Capture a single frame
 */
ipcMain.handle(
  'camera:capture',
  async (_event, settings?: Partial<CameraSettings>) => {
    try {
      const camera = await ensureCameraProcess();
      const response = await camera.capture(settings);

      if (response.success && response.image) {
        return {
          dataUri: response.image,
          timestamp: Date.now(),
          width: response.width || 0,
          height: response.height || 0,
        };
      } else {
        throw new Error(response.error || 'Capture failed');
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('camera:capture error:', error);
      throw error;
    }
  }
);

/**
 * Handle camera:get-status - Get camera status
 */
ipcMain.handle('camera:get-status', async () => {
  try {
    if (!cameraProcess) {
      return { connected: false, mock: true, available: false };
    }
    const status = await cameraProcess.getStatus();
    return status;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:get-status error:', error);
    return { connected: false, mock: true, available: false };
  }
});

/**
 * Handle camera:get-settings - Get current camera settings
 */
ipcMain.handle('camera:get-settings', async () => {
  console.log(
    '[camera:get-settings] Returning settings:',
    currentCameraSettings
  );
  return currentCameraSettings;
});

/**
 * Handle camera:start-stream - Start streaming frames from camera
 */
ipcMain.handle(
  'camera:start-stream',
  async (_event, settings?: Partial<CameraSettings>) => {
    try {
      const camera = await ensureCameraProcess();
      const success = await camera.startStream(settings);
      return { success };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('camera:start-stream error:', error);
      return { success: false, error: error.message };
    }
  }
);

/**
 * Handle camera:stop-stream - Stop streaming frames from camera
 */
ipcMain.handle('camera:stop-stream', async () => {
  try {
    if (!cameraProcess) {
      return { success: true }; // Already stopped
    }
    const success = await cameraProcess.stopStream();
    return { success };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:stop-stream error:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Handle camera:detect-cameras - Detect available cameras on network
 */
ipcMain.handle('camera:detect-cameras', async () => {
  try {
    const camera = await ensureCameraProcess();
    const cameras = await camera.detectCameras();
    return { success: true, cameras };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('camera:detect-cameras error:', error);
    return { success: false, error: error.message, cameras: [] };
  }
});

// =============================================================================
// IPC Handlers for DAQ Communication
// =============================================================================

/**
 * Initialize DAQ subprocess if not already initialized
 */
async function ensureDAQProcess(): Promise<DAQProcess> {
  if (!daqProcess) {
    const pythonPath = getPythonExecutablePath();
    daqProcess = new DAQProcess(pythonPath, ['--ipc']);

    // Forward DAQ events to renderer
    daqProcess.on('daq-initialized', () => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('daq:initialized');
      }
    });

    daqProcess.on('daq-position-changed', (position: number) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('daq:position-changed', { position });
      }
    });

    daqProcess.on('daq-home', () => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('daq:home');
      }
    });

    daqProcess.on('status', (status: string) => {
      console.log('DAQ status:', status);
    });

    daqProcess.on('error', (error: string) => {
      console.error('DAQ error:', error);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('daq:error', error);
      }
    });

    daqProcess.on('exit', (code: number | null) => {
      console.log(`DAQ process exited with code ${code}`);
      daqProcess = null;
    });

    await daqProcess.start();
  }

  return daqProcess;
}

/**
 * Handle daq:initialize - Initialize DAQ with settings
 */
ipcMain.handle('daq:initialize', async (_event, settings: DAQSettings) => {
  try {
    const daq = await ensureDAQProcess();
    const response = await daq.initialize(settings);
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:initialize error:', error);
    return { success: false, initialized: false, error: error.message };
  }
});

/**
 * Handle daq:cleanup - Clean up DAQ resources
 */
ipcMain.handle('daq:cleanup', async () => {
  try {
    if (!daqProcess) {
      return { success: true, initialized: false }; // Already cleaned up
    }
    const response = await daqProcess.cleanup();
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:cleanup error:', error);
    return { success: false, initialized: false, error: error.message };
  }
});

/**
 * Handle daq:rotate - Rotate turntable by degrees
 */
ipcMain.handle('daq:rotate', async (_event, degrees: number) => {
  try {
    if (!daqProcess) {
      throw new Error('DAQ not initialized. Call initialize() first.');
    }
    const response = await daqProcess.rotate(degrees);
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:rotate error:', error);
    return { success: false, position: 0, error: error.message };
  }
});

/**
 * Handle daq:step - Execute specific number of steps
 */
ipcMain.handle(
  'daq:step',
  async (_event, numSteps: number, direction: 1 | -1 = 1) => {
    try {
      if (!daqProcess) {
        throw new Error('DAQ not initialized. Call initialize() first.');
      }
      const response = await daqProcess.step(numSteps, direction);
      return response;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('daq:step error:', error);
      return { success: false, position: 0, error: error.message };
    }
  }
);

/**
 * Handle daq:home - Return turntable to home position
 */
ipcMain.handle('daq:home', async () => {
  try {
    if (!daqProcess) {
      throw new Error('DAQ not initialized. Call initialize() first.');
    }
    const response = await daqProcess.home();
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:home error:', error);
    return { success: false, position: 0, error: error.message };
  }
});

/**
 * Handle daq:get-status - Get DAQ status
 */
ipcMain.handle('daq:get-status', async () => {
  try {
    if (!daqProcess) {
      return {
        success: true,
        initialized: false,
        position: 0,
        mock: true,
        available: false,
      };
    }
    const status = await daqProcess.getStatus();
    return status;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('daq:get-status error:', error);
    return {
      success: false,
      initialized: false,
      position: 0,
      mock: true,
      available: false,
      error: error.message,
    };
  }
});

// =============================================================================
// IPC Handlers for Scanner Communication
// =============================================================================

/**
 * Initialize Scanner subprocess if not already initialized
 */
async function ensureScannerProcess(): Promise<ScannerProcess> {
  if (!scannerProcess) {
    // Scanner uses the same Python process as other hardware
    if (!pythonProcess) {
      throw new Error('Python process not initialized');
    }

    scannerProcess = new ScannerProcess(pythonProcess);

    // Forward scanner events to renderer
    scannerProcess.on('initialized', () => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('scanner:initialized');
      }
    });

    scannerProcess.on('progress', (progress) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('scanner:progress', progress);
      }
    });

    scannerProcess.on('complete', (result) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('scanner:complete', result);
      }
    });

    scannerProcess.on('error', (error: string) => {
      console.error('Scanner error:', error);
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('scanner:error', error);
      }
    });
  }

  return scannerProcess;
}

/**
 * Handle scanner:initialize - Initialize scanner with camera and DAQ settings
 */
ipcMain.handle(
  'scanner:initialize',
  async (_event, settings: ScannerSettings) => {
    try {
      const scanner = await ensureScannerProcess();
      const response = await scanner.initialize(settings);
      return response;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      console.error('scanner:initialize error:', error);
      return { success: false, initialized: false, error: error.message };
    }
  }
);

/**
 * Handle scanner:cleanup - Clean up scanner resources
 */
ipcMain.handle('scanner:cleanup', async () => {
  try {
    if (!scannerProcess) {
      return { success: true, initialized: false }; // Already cleaned up
    }
    const response = await scannerProcess.cleanup();
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('scanner:cleanup error:', error);
    return { success: false, initialized: false, error: error.message };
  }
});

/**
 * Handle scanner:scan - Perform a complete scan
 */
ipcMain.handle('scanner:scan', async () => {
  try {
    if (!scannerProcess) {
      throw new Error('Scanner not initialized. Call initialize() first.');
    }
    const response = await scannerProcess.scan();
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('scanner:scan error:', error);
    return {
      success: false,
      frames_captured: 0,
      output_path: '',
      error: error.message,
    };
  }
});

/**
 * Handle scanner:get-status - Get scanner status
 */
ipcMain.handle('scanner:get-status', async () => {
  try {
    if (!scannerProcess) {
      return {
        success: true,
        initialized: false,
        camera_status: 'unknown',
        daq_status: 'unknown',
        position: 0,
        mock: true,
      };
    }
    const status = await scannerProcess.getStatus();
    return status;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    console.error('scanner:get-status error:', error);
    return {
      success: false,
      initialized: false,
      camera_status: 'unknown',
      daq_status: 'unknown',
      position: 0,
      mock: true,
      error: error.message,
    };
  }
});

/**
 * Handle scanner:get-scanner-id - Get current scanner identity
 *
 * Returns the scanner's configured name from runtime state.
 * Matches pilot API: scanner.getScannerId()
 *
 * @returns {string} Scanner name or empty string if not configured
 */
ipcMain.handle('scanner:get-scanner-id', (): string => {
  return scannerIdentity.name;
});

// =============================================================================
// IPC Handlers for Configuration
// =============================================================================

/**
 * Handle config:get - Get current configuration and credentials
 * Returns config values with password masked for security
 */
ipcMain.handle('config:get', async () => {
  try {
    // Load unified config from .env
    const config = loadEnvConfig(ENV_PATH);
    const hasCredentials = config.bloom_scanner_password !== '';

    // Return unified config with masked password
    return {
      config: {
        scanner_name: config.scanner_name,
        camera_ip_address: config.camera_ip_address,
        scans_dir: config.scans_dir,
        bloom_api_url: config.bloom_api_url,
        bloom_scanner_username: config.bloom_scanner_username,
        bloom_scanner_password: hasCredentials ? '********' : '',
        bloom_anon_key: config.bloom_anon_key,
      },
      hasCredentials,
    };
  } catch (error) {
    console.error('config:get error:', error);
    throw error;
  }
});

/**
 * Handle config:set - Save unified configuration
 * Validates config before saving
 */
ipcMain.handle('config:set', async (_event, config: MachineConfig) => {
  try {
    // Validate config (validateConfig needs to be updated to handle credential fields)
    const validation = validateConfig(config);
    if (!validation.valid) {
      return { success: false, errors: validation.errors };
    }

    // Save unified config to .env
    saveEnvConfig(config, ENV_PATH);

    return { success: true };
  } catch (error) {
    console.error('config:set error:', error);
    return {
      success: false,
      errors: {
        general:
          error instanceof Error ? error.message : 'Unknown error occurred',
      },
    };
  }
});

/**
 * Handle config:test-camera - Test connection to camera at given IP
 */
ipcMain.handle('config:test-camera', async (_event, ipAddress: string) => {
  try {
    // For 'mock' camera, always succeed
    if (ipAddress === 'mock') {
      return { success: true };
    }

    // Try to connect to the camera using CameraProcess
    const camera = await ensureCameraProcess();
    const connectResult = await camera.connect({
      ...DEFAULT_CAMERA_SETTINGS,
      camera_ip_address: ipAddress,
    });

    if (connectResult) {
      // Disconnect after successful test
      await camera.disconnect();
      return { success: true };
    } else {
      return {
        success: false,
        error: `Failed to connect to camera at ${ipAddress}`,
      };
    }
  } catch (error) {
    console.error('config:test-camera error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
});

/**
 * Handle config:browse-directory - Open native folder picker dialog
 */
ipcMain.handle('config:browse-directory', async () => {
  try {
    if (!mainWindow) {
      return null;
    }

    const result = await dialog.showOpenDialog(mainWindow, {
      properties: ['openDirectory', 'createDirectory'],
      title: 'Select Scans Directory',
    });

    if (result.canceled || result.filePaths.length === 0) {
      return null;
    }

    return result.filePaths[0];
  } catch (error) {
    console.error('config:browse-directory error:', error);
    return null;
  }
});

/**
 * Handle config:exists - Check if configuration file exists
 * Used for first-run detection
 */
ipcMain.handle('config:exists', async () => {
  try {
    // Check if .env file exists (unified config)
    return fs.existsSync(ENV_PATH);
  } catch (error) {
    console.error('config:exists error:', error);
    return false;
  }
});

/**
 * Handle config:fetch-scanners - Fetch valid scanners from Bloom API
 * Updated to accept parameters (apiUrl and credentials) from form
 */
ipcMain.handle(
  'config:fetch-scanners',
  async (
    _event,
    apiUrl: string,
    credentials: {
      bloom_scanner_username: string;
      bloom_scanner_password: string;
      bloom_anon_key: string;
    }
  ) => {
    try {
      // Validate parameters
      if (
        !apiUrl ||
        !credentials.bloom_scanner_username ||
        !credentials.bloom_scanner_password ||
        !credentials.bloom_anon_key
      ) {
        return {
          success: false,
          error: 'Bloom API URL and credentials are required',
        };
      }

      const result = await fetchScannersFromBloom(apiUrl, credentials);

      return result;
    } catch (error) {
      console.error('config:fetch-scanners error:', error);
      return {
        success: false,
        error:
          error instanceof Error ? error.message : 'Failed to fetch scanners',
      };
    }
  }
);

// =============================================================================
// App Lifecycle
// =============================================================================

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  createWindow();

  // Initialize database AFTER window is created so we can send errors to renderer
  try {
    console.log('[Main] Initializing database...');
    initializeDatabase();
    console.log('[Main] Database initialized, registering handlers...');
    registerDatabaseHandlers();
    console.log('[Main] Database initialized and handlers registered');

    // Send success message to renderer
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('database:ready', { success: true });
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error(
      '[Main] Failed to initialize database:',
      errorMessage,
      errorStack
    );

    // Send error to renderer so user can see it in DevTools
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('database:error', {
        error: errorMessage,
        stack: errorStack,
      });
    }
  }

  await initializePythonProcess();

  // Initialize scanner identity from config
  try {
    const config = loadEnvConfig(ENV_PATH);
    scannerIdentity.name = config.scanner_name || '';
    console.log(
      '[Scanner Identity] Initialized:',
      scannerIdentity.name || '(not configured)'
    );
  } catch (error) {
    console.error('[Scanner Identity] Failed to initialize:', error);
    scannerIdentity.name = '';
  }
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Clean up processes before app quits
let isQuitting = false;
app.on('before-quit', async (event) => {
  // Prevent infinite loop - only run cleanup once
  if (isQuitting) {
    return;
  }

  console.log('App is quitting, cleaning up processes...');
  isQuitting = true;

  // Prevent immediate quit to allow cleanup
  event.preventDefault();

  try {
    // Stop camera streaming first with timeout
    if (cameraProcess) {
      console.log('Stopping camera streaming...');
      let stopStreamCompleted = false;
      const stopStreamPromise = cameraProcess.stopStream().then(() => {
        stopStreamCompleted = true;
      });
      await Promise.race([
        stopStreamPromise,
        new Promise((resolve) => setTimeout(resolve, STOP_STREAM_TIMEOUT_MS)),
      ]);
      if (stopStreamCompleted) {
        console.log('Camera stream stopped successfully');
      } else {
        console.warn(
          'Camera stream stop timed out, force-stopping camera process...'
        );
        try {
          cameraProcess.stop();
        } catch (stopErr) {
          console.error('Error force-stopping camera process:', stopErr);
        }
      }
    }

    // Stop all processes
    if (pythonProcess) {
      console.log('Stopping Python process...');
      pythonProcess.stop();
      console.log('Python process stopped');
    }
    if (cameraProcess) {
      console.log('Stopping camera process...');
      cameraProcess.stop();
      console.log('Camera process stopped');
    }
    if (daqProcess) {
      console.log('Stopping DAQ process...');
      daqProcess.stop();
      console.log('DAQ process stopped');
    }

    // Close database connection
    console.log('Closing database connection...');
    await closeDatabase();
    console.log('Database connection closed');

    // Give processes a moment to clean up
    console.log('Waiting 500ms for processes to clean up...');
    await new Promise((resolve) => setTimeout(resolve, 500));
    console.log('Cleanup wait complete');
  } catch (err) {
    console.error('Error during cleanup:', err);
  }

  // Now allow the quit - use exit instead of quit to avoid triggering before-quit again
  console.log('Calling app.exit(0)...');
  app.exit(0);
});

// Clean up processes when app quits (fallback)
app.on('quit', () => {
  if (pythonProcess) {
    pythonProcess.stop();
  }
  if (cameraProcess) {
    cameraProcess.stop();
  }
  if (daqProcess) {
    daqProcess.stop();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
